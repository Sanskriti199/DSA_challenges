class Solution {
public:
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        vector<double> ans;
        unordered_map<string, unordered_map<string, double>> graph;
        
        for (int i = 0; i < equations.size(); ++i) {
            const string& A = equations[i][0];
            const string& B = equations[i][1];
            graph[A][B] = values[i];
            graph[B][A] = 1.0 / values[i];
        }
        
        for (const vector<string>& query : queries) {
            const string& A = query[0];
            const string& C = query[1];
            if (graph.find(A) == graph.end() || graph.find(C) == graph.end()) {
                ans.push_back(-1.0);
            } else {
                ans.push_back(divide(graph, A, C, unordered_set<string>()));
            }
        }
        
        return ans;
    }
    
private:
    double divide(const unordered_map<string, unordered_map<string, double>>& graph,
                  const string& A, const string& C, unordered_set<string> seen) {
        if (A == C) return 1.0;
        
        seen.insert(A);
        
        auto it = graph.find(A);
        if (it != graph.end()) {
            for (const auto& p : it->second) {
                const string& B = p.first;
                double value = p.second;
                if (seen.find(B) != seen.end()) continue;
                
                double res = divide(graph, B, C, seen);
                if (res > 0) {
                    return value * res;
                }
            }
            }
        
        return -1.0;
}
};
